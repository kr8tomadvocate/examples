If you use Apollo Federation to federate subgraphs, you can use StepZen to build those subgraphs. With little effort, the StepZen created and deployed subgraphs are Apollo Federation ready. Let's walk you through how to get it done.

## Create Subgraphs in StepZen
StepZen is a very easy way of generating subgraphs. You can either (i) introspect the backends (the approach we will be using here, and is detailed in the [stepzen import](https://stepzen.com/docs/quick-start) section of our docs, or (ii) add `@rest` and `@dbquery` directives in your SDL to connect to backends (detailed in the [Custom Directives](https://stepzen.com/docs/connecting-backends) section of our docs). Here we will use the `stepzen import` method. 
1. [Signup](https://stepzen.com/signup) for StepZen.
1. Follow the instructions on [Gdetting Started](https://stepzen.com/getting-started) to get the `cli` installed and to `login`.
1. Create a working directory `apollo-federation` and `cd` to it. 
1. Create a working subdirectory in the above directory called `customers` and `cd` to it.
1. `stepzen import mysql` using the credentials of MySQL introspection in [getting-started](https://stepzen.com/getting-started/examples).
1. Now you have a subgraph that contains customer, address (a customer can have more than one address) and their orders all from the mysql database, with StepZen creating types, queries, mutations all for you. All from one simple command of `stepzen import mysql`. Of course, you can modify this auto-generated subgraph, but we will leave it as is. See the `@dbquery` annotations in the generated code.
1. Let's make this endpoint public (makes it easier to federate in Apollo). Add the following to the end of the `config.yaml` file generated by the previous step:
  ```yaml
  ruleset:
    - query: "[ALL]"
      rules:
        - predicate: true
          action: allow
  ```
1. `stepzen start --port=5001` and pick the name of the API endpoint to be `api/customers` (or whatever you like, just remember it). This is all that is needed to deploy the generated code to the StepZen cloud, protect it with API keys, and scale it as you need it. The file `config.yaml` stores keys for the backend separate from the code--always a good practice. The file `index.graphql` is the manifest file that tells `stepzen start` to deploy the sets of `.graphql` files in `index.graphql`. The `--port=5001` creates a local proxy at `http://localhost:5001`. The local proxy automatically uses the admin API Key to connect to the cloud deployed GraphQL API.
1. Go to a new shell and make a new subdirectory in `apollo-federation` called `returns`. `cd` to it.
1. `stepzen import curl "https://json2api-returns-p2axj4bzta-uw.a.run.app/returns?q=city+eq+Boston" --name=returnStores --query-name=returnStores --query-type=ReturnStore`. 
1. Edit the generated file to:
  ```graphql
  ...
  type Query {
    returnStores(city: String): [ReturnStoreEntry]
    @rest(endpoint: "https://json2api-returns-p2axj4bzta-uw.a.run.app/returns?q=city+eq+$city")
  }
  ```
  that changes the query string to be just the city name.
1. Now you have a subgraph that takes a city name and returns some stores where packages could be returned (it is all dummy data, so do not go looking for the stores or even the street names!). One line of `stepzen import curl` did all this for you. If you examine the generated code, you will see `@res` annotations.
1. Let's make this endpoint public (makes it easier to federate in Apollo). Since the backend is public, there is no `config.yaml` generated for it. Create a file called `config.yaml` with the following content:
  ```yaml
  ruleset:
    - query: "[ALL]"
      rules:
        - predicate: true
          action: allow
  ```
1. `stepzen start --port=5002` and pick the name of the API endpoint to be `api/returns` (or whatever you like, just remember it). This is all that is needed to deploy the generated code to the StepZen cloud, protect it with API keys, and scale it as you need it. The file `index.graphql` is the manifest file that tells `stepzen start` to deploy the sets of `.graphql` files in `index.graphql`. The `--port=5002` creates a local proxy at `http://localhost:5001`. The local proxy automatically uses the admin API Key to connect to the cloud deployed GraphQL API.

Now you have two subgraphs, `api/customers` and `api/returns`. You can try the two subgraphs (which are running on public endpoints with the two local proxies that we have helpfully created for you: [customers](http://localhost:5001) and [returns](http://localhost:5002)). If you want to connect directly to the cloud deployed subgraphs, you must add your API key as a header (follow the instructions for [Connecting to StepZen](https://stepzen.com/docs/connecting-frontends/connecting-to-stepzen)).

## Making the subgraphs ready for Apollo Federation
We will be adding data from subgraph `returns` to the `type Address` in the subgraph `customers`. When we do that, and set up Apollo federation, we will be able to get all the stores where packages can be returned associated with that address.
1. Add `@key`Modify `customers/mysql/mysql.graphql` by editing the following:
  ```graphql
  type Address @key (fields: "id") {
    ...
  }
  ```
  Save the file, and redploy it (if `stepzen start --port=5001` has stopped running, though if you had it in a separate shell, it should still be running). 
  All we did in the above code is to tell Apollo Federation that the Address object can be fetched using its `"id"` field. All the resolvers, `_service` and `_entities` that Apollo needs are automatically generated by StepZen--nothing for you to do!
1. Modify `returns/returnStores/index.graphql` by adding the following:
  ```graphql
  type Address @key (fields: "id") {
    id: Int!
    city: @external
    returnStores: [ReturnStoreEntry]
    @materializer (query: "returnStores")
  }
  ```
  Save the file, and redploy it (if `stepzen start --port=5002` has stopped running, though if you had it in a separate shell, it should still be running).
  For Apollo Federation to work, we have to define `type Address` on both sides, with each side declaring the fields it returns (in addition to the `@key` fields). Since `api/returns` adds the field `returnStores` to `type Address` we declare it here. We also need to do two things:
  - Add an `@materializer` that tells StepZen how to populate the field `returnStores` (this is standard StepZen construct that [stitches types](https://stepzen.com/docs/stitching) in StepZen)
  - And add `city: String @external` so that Apollo Federation knows that in addition to sending down the key `id`, it should also send down `city` (which stepZen needs to populate `returnStores`, i.e. to execute the query `returnStores` that takes a parameter `city`).

  All other requirements for Apollo (`_service`, `entities`, `@required` etc. are taken care of by StepZen automatically, there is nothing for you to do).

  ## Federate subgraphs in Apollo
  We assume that you are familiar with how [Apollo Federation[(https://www.apollographql.com/docs/federation/)] works. We will only cover the basics. We will be doing an Apollo Studio supergraph creation.
  1. [Signup for Apollo]() 
  1. Create a supergraph in Apollo Studio.
  1. Install rover
  1. Upload the schema of the two subgraphs using the following code:

  blah blah